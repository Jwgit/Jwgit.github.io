{"meta":{"title":"Jing","subtitle":null,"description":null,"author":"Jing","url":"http://Jwgit.github.io"},"pages":[{"title":"","date":"2017-05-20T08:38:50.000Z","updated":"2017-05-20T08:38:50.000Z","comments":false,"path":"categories/index.html","permalink":"http://Jwgit.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-05-20T08:38:17.000Z","updated":"2017-05-20T08:38:17.000Z","comments":false,"path":"tags/index.html","permalink":"http://Jwgit.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2017-05-20T07:53:21.000Z","updated":"2017-05-20T07:53:21.000Z","comments":true,"path":"2017/05/20/hello-world/","link":"","permalink":"http://Jwgit.github.io/2017/05/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"函数节流和函数防抖","slug":"throttle-debounce","date":"2017-05-05T09:00:35.000Z","updated":"2017-05-20T15:38:15.000Z","comments":true,"path":"2017/05/05/throttle-debounce/","link":"","permalink":"http://Jwgit.github.io/2017/05/05/throttle-debounce/","excerpt":"函数节流：指定时间间隔内只允许执行一次任务 函数防抖：任务触发频繁的情况下，只有任务触触发的时间超过指定时间间隔的时候，任务才开始执行","text":"函数节流：指定时间间隔内只允许执行一次任务 函数防抖：任务触发频繁的情况下，只有任务触触发的时间超过指定时间间隔的时候，任务才开始执行 函数节流(throttle)1234567891011function throttle(fn, interval = 300) &#123; let canRun = true; return function () &#123; if (!canRun) return; canRun = false; setTimeout(() = &gt; &#123; fn.apply(this, arguments); canRun = true; &#125;, interval); &#125;&#125; 函数的节流就是通过闭包保存一个标记（canRun = true）在函数开始的时候判断这个标记是否为true ， 如果为true则继续执行函数，否则return掉。判断完后修改这个标记为false ，然后把外部的传入函数的执行包在一个setTimeout中，最后在setTimeout执行完后把这个标记设置为true,表示可以下一次循环了。当定时器还未执行的时候，标记始终为false,在开始判断的时候就被return掉 函数防抖(debounce)123456789function debounce(fn, interval = 300) &#123; let timeout = null; return function () &#123; clearTimeout(timeout); timeout = setTimeout(() = &gt; &#123; fn.apply(this, arguments); &#125;, interval); &#125;&#125; 函数防抖就是通过闭包保存一个标记保存setTimeout 返回的值，当多次调用的时候，都会把前面的一个setTimeout clear掉，然后重新创建一个新的setTimeout ，这样保证在interval内就不会多次触发fn函数。","categories":[],"tags":[]}]}